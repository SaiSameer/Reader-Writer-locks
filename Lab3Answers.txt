Additional Tasks

1.The priority inversion problem could cause that a higher-priority process needs to wait for the completion of a lower-priority process.
	1. Priority inheritance is one approach to address this issue. Please give another approach and briefly describe its idea.
	
	Ans:Another approaches to solve priority inversion can be listed as follows: Priority ceiling, Random boosting etc. 
	In priority ceiling, each resource is given a priority equal to the maximum of the priorities of the tasks that can lock the resource. 
	Then on the event of a priority inverision or deadlock, the priority of the low-priority process holding the resource is boosted to the priority ceiling of the resource.
	This allows the low priority process to quickly complete its tasks on the resource without interruptions as other tasks that can hold the lock cannnot be scheduled until this process releases it.
	This change of priority to the low priority process to the ceil can be made in two different ways: OCPP(Original Ceiling Priority Protocol) and ICPP(Immediate Ceiling Priority Protocol). 
	In OCPP the priority is boosted only when a higher priority process tries to acquire the lock. Whereas in ICPP the priority is boosted immediately as it acquires the resource.

	Reference:
		(i) https://en.wikipedia.org/wiki/Priority_ceiling_protocol
	
	2.Design a test case to show that your approach can address the priority inversion problem. You should compare the results that derived from the original XINU implementation (use semaphore) and that derived from your implementation (use readers/writer locks). Put your results in Lab3Answers.txt and your test case program (name it task1.c) in both ./sys and ./TMP
	
2.Synchronization is a quite complex issue in operating systems. To show your understanding about process synchronization, you are asked to point out a reader/writer synchronization issue in this pesudo-code: task2_sync_issue.c. Multiple reader threads can execute this code concurrently by calling do_update. All the variables starting with global_ are global variables. You are asked to describe the potential issue caused by the incorrect synchronization and point out at least one possible thread interleaving that would trigger the problem. Put your answer in Lab3Answers.txt mentioned above.

Ans: The psuedo code in the given file shows that in do_update, each reader thread aquires a reader lock and tries to update the global buffer with current time. 
As it is a reader lock, multiple readers can acquire the lock and make changes to the global buffer simulltaneously. 
Although a global semophore is acquired and locked before updating the global buffer, as the global semophore is initialized to 10, 10 processes can simultaneously acquire it.
Then if one of the process preempts or context switching occurs of other cause they can concurrently modify it corrupting the information in the buffer.
Inorder to rectify this the lock to make updates to the buffer should be exclusive that is a writer lock must be obtained to make changes.
